---
title: Golang并发控制
date: 2020-05-13 23:10:07
categories:
  - Golang
tags:
  - Golang
---

## 前言

最近决定研究下 Golang，借助王垠大神的说法就是学习一门语言优先从他的特性入手，我们的 Golang 的特性就是 goroutine。这个 goroutine 是一个什么东西呢？就像是漩涡鸣人的影分身。

## Goroutine 最简单的例子

我们要在 Golang 中使用协程最简单的方法就是在对应函数前面使用 `go` 关键字。

```go
package main

import (
    "fmt"
)

func hello() {
    fmt.Println("Hello Goroutine")
}

func main() {
    go hello()
}
```

<!-- more -->

我们直接执行就会发现没有任何执行结果，这是为嘛吖？小朋友你是否有很多问号。因为我们的 `main` 也是一个 goroutine，他是主 goroutine，因为主没有任何的阻塞，主 goroutine（主体鸣人受伤） 快速执行退出，导致其他的 goroutine（影分身） 没有被执行就退出了。

我们来试试简单的修改，让其他 goroutine 也能返回执行出结果。

```go
package main

import (
    "fmt"
    "time"
)

func hello() {
    fmt.Println("Hello Goroutine")
}

func main() {
    go hello()
    time.Sleep(2 * time.Second)
}
```

这样的问题就是，我们不知道我们的 goroutine 什么时候才会结束啊。不可能无限制延长 `time.Sleep` 的时间吧，这样不科学。

## 同步 Goroutine

我们同步 Goroutine 的方式：

- Channel
- sync 包

### Channel

我们可以使用 Channel 在通道之间传递值，当然因为 channel 有会阻塞的特性，可以利用这特性来进行协程同步。

```go
package main

import "fmt"

func hello(i chan int) {
    fmt.Println("Hello Goroutine")
    <-i
}

func main() {
    // 无缓存channel
    // 根据Go语言内存模型规范，对于从无缓冲Channel进行的接收，发生在对该Channel进行的发送完成之前
    i := make(chan int)
    go hello(i)
    i <- 1
}
```

这个是无缓存 channel 的，在 goroutine 中，channel 先执行了打印语句，然后阻塞等待接收值，知道主 goroutine 告诉他，值来了（你歇着吧）。整个程序流程才会结束。

当然在有缓存的 channel 中这种顺序需要调换一下，否则你会发现程序啥也不输出。

```go
package main

import "fmt"

func hello(i chan int) {
    fmt.Println("Hello Goroutine")
    i <- 1
}

func main() {
    // 有缓存channel
    // 对于带缓冲的Channel，对于Channel的第K个接收完成操作发生在第K+C个发送操作完成之前，其中C是Channel的缓存大小。
    i := make(chan int, 1)
    go hello(i)
    <-i
}
```

在我们的接收之前，必须完成发送，否则会发生死锁阻塞。

### sync 包

我们也可以使用 sync 包提供的功能进行 goroutine 的同步。

```go
package main

import (
    "fmt"
    "sync"
)

func hello(wg *sync.WaitGroup) {
    fmt.Println("Hello World")
    wg.Done()
}

func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go hello(&wg)

    // 等待结束
    wg.Wait()
}
```

## 利用缓存 channel+sync 包实现对 goroutine 并发控制

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {

    wg := &sync.WaitGroup{}

    limiter := make(chan bool, 10)
    for i := 0; i < 100; i++ {
        wg.Add(1)
        limiter <- true // 当传入 10 后，如果没有接收通道会阻塞，达到我们控制协程并发的效果
        go download(i, limiter, wg)
    }
    wg.Wait()
}

func download(index int, limiter chan bool, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Println("start to download :", index)
    time.Sleep(1 * time.Second)
    <-limiter
}
```

## 总结

我总结的这些只是我目前为止所见所学，当然会有更加复杂的方式。希望能在后续工作中用到。
