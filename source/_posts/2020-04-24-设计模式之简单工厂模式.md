---
title: 设计模式之简单工厂（静态工厂模式）
date: 2020-04-24 20:27:53
categories:
  - 设计模式
tags:
  - 设计模式
---

## 前言

简单工厂模式（静态工厂模式），最为一个出镜率比较高的设计模式，相对来说比较简单，大家可以很快上手，我觉得还是举例子给大家会比较好理解也记忆。

我们首先看看它的优缺点：

- 优点是比较好理解，简单易操作
- 缺点是违反了设计模式的 OCP 原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码或者尽量少修改代码

## 理想小镇的聪明面包达人

我们想象一下，一个理想小镇上有个面包达人，他教会了好几个徒弟，徒弟们也准守传承按照指定的配方去做面包，每当想到一个新的做法面包达人都要挨个徒弟的教会他们。

<!-- more -->

我们就先模拟一下这个远古笨办法，我们定义一个面包的抽象类，每种面包我们都可以继承这个基础类，然后两个徒弟都开始要做面包就会有以下的代码：

```java
package com.yubulang.simplefactory;

// 我们要生产一个相机，是要准备不同的
public abstract class Bread {
    // 准备材料
    public abstract void prepare();

    // 制作
    public abstract void make();

    // 包装
    public abstract void pack();
}

public class ButterBread extends Bread {
    public void prepare() {
        System.out.println("准备奶油面包的材料");
    }

    public void make() {
        System.out.println("制作奶油面包");
    }

    public void pack() {
        System.out.println("包装奶油面包");
    }
}

public class MeatLoaf extends Bread {
    public void prepare() {
        System.out.println("准备肉松面包的材料");
    }

    public void make() {
        System.out.println("制作肉松面包");
    }

    public void pack() {
        System.out.println("包装肉松面包");
    }
}

class Apprentice01 {
    public static void makeBread(String name) {
        Bread bread = null;
        switch (name) {
            case "肉松面包":
                bread = new MeatLoaf();
                break;
            case "奶油面包":
                bread = new ButterBread();
                break;
        }

        if (bread != null) {
            System.out.println("徒弟一：");
            bread.make();
            bread.pack();
            System.out.println("徒弟一卖面包");
        }
    }
}

class Apprentice02 {
    public static void makeBread(String name) {
        Bread bread = null;
        switch (name) {
            case "肉松面包":
                bread = new MeatLoaf();
                break;
            case "奶油面包":
                bread = new ButterBread();
                break;
        }

        if (bread != null) {
            System.out.println("徒弟二：");
            bread.make();
            bread.pack();
            System.out.println("徒弟二卖面包");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Apprentice01.makeBread("奶油面包");
        Apprentice02.makeBread("奶油面包");
    }
}
```

这个时候我们还有香肠面包、香肠面包要交给徒弟，那么我们代码要改的地方是不是有很多地方了。这个时候面包达人看出问题了，每个徒弟都要教一遍怎么做新面包是不是很累，那我们把他们叫一起来，一锅烩了岂不是更快。

统一课堂（及工厂）分开教的小灶变成了大课堂。这个大课堂我们可以把它看成一个规范的工厂。代码升级：

```java
package com.yubulang.simplefactory;

// 我们要生产一个相机，是要准备不同的
public abstract class Bread {
    // 准备材料
    public abstract void prepare();

    // 制作
    public abstract void make();

    // 包装
    public abstract void pack();
}

public class ButterBread extends Bread {
    public void prepare() {
        System.out.println("准备奶油面包的材料");
    }

    public void make() {
        System.out.println("制作奶油面包");
    }

    public void pack() {
        System.out.println("包装奶油面包");
    }
}

public class MeatLoaf extends Bread {
    public void prepare() {
        System.out.println("准备肉松面包的材料");
    }

    public void make() {
        System.out.println("制作肉松面包");
    }

    public void pack() {
        System.out.println("包装肉松面包");
    }
}

// 大课堂教授徒弟们做面包
public class SimpleFactory {
    public static Bread createBread(String name) {
        Bread bread = null;
        switch (name) {
            case "肉松面包":
                bread = new MeatLoaf();
                break;
            case "奶油面包":
                bread = new ButterBread();
                break;
        }

        return bread;
    }
}

class Apprentice01 {
    public static void makeBread(String name) {
        Bread bread = SimpleFactory.createBread(name);

        if (bread != null) {
            System.out.println("徒弟一：");
            bread.make();
            bread.pack();
            System.out.println("徒弟一卖面包");
        }
    }
}

class Apprentice02 {
    public static void makeBread(String name) {
        Bread bread = SimpleFactory.createBread(name);

        if (bread != null) {
            System.out.println("徒弟二：");
            bread.make();
            bread.pack();
            System.out.println("徒弟二卖面包");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Apprentice01.makeBread("奶油面包");
        Apprentice02.makeBread("奶油面包");
    }
}
```

这样我们的面包达人是不是就省事儿了不少。教一次两个徒弟都会了，如果要挨个挨个教（挨个挨个的改代码就太累了）。所以我们把这些共有的部分抽离出来，节省大家的时间。

## 总结

这里我们已经看出简单工厂模式的简单强大之处了吧——其实就是把创建对象的公用部抽取独立出来了。

但是这个不是一个好方式，因为你每次添加新对象的时候都要去修改这个类，逻辑上是没问题，但是从代码上来说这不是一个好办法。

别急后面还有好几种工厂模式，可以为我们提供解决的思路。
